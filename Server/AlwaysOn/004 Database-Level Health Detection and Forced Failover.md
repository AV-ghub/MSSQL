### **1. Обнаружение работоспособности на уровне БД (Database-Level Health Detection)**

**Что это такое?**
Это дополнительный, более строгий механизм мониторинга в AlwaysOn, введенный в SQL Server 2012. По умолчанию AG отслеживает работоспособность **на уровне экземпляра SQL Server и его реплики** (например, крах службы SQL, зависание, нехватка системных ресурсов). **База данных при этом может быть "мертва"** (например, из-за потери файлов данных, недоступности файловой системы, сбоя страниц), но экземпляр и реплика будут считаться работоспособными, и автоматический failover не сработает.

Механизм **Database-Level Health Detection** как раз отслеживает состояние **отдельных баз данных** в группе. Если одна из баз данных входит в состояние ошибки (`SUSPECT`), это может инициировать автоматический переход на другой ресурс при соблюдении других условий.

**Где и как настраивается?**
Это настраивается **для всей группы доступности** с помощью Transact-SQL. Основной параметр — `DB_FAILOVER`.

```sql
-- Включение обнаружения сбоев на уровне базы данных
ALTER AVAILABILITY GROUP [Your_AG_Name]
SET (DB_FAILOVER = ON);

-- Выключение обнаружения сбоев на уровне базы данных (поведение по умолчанию до SQL Server 2016)
ALTER AVAILABILITY GROUP [Your_AG_Name]
SET (DB_FAILOVER = OFF);
```

**Важные нюансы:**
*   **При `DB_FAILOVER = ON`:** Если любая база данных в группе становится недоступной на первичной реплике, это рассматривается как сбой всей реплики, что **может** спровоцировать автоматический failover на синхронизированную вторичную реплику (если она есть).
*   **При `DB_FAILOVER = OFF` (или по умолчанию в ранних версиях):** Проблемы с отдельной БД не вызовут автоматического failover. Это может быть полезно, если в группе есть "некритичная" база данных, сбой которой не должен влиять на работу всей группы.
*   **С SQL Server 2016 SP1:** Параметр `DB_FAILOVER` по умолчанию **включен (`ON`)** для новых групп доступности.

**Сценарий для собеседования:** Вас спрашивают: *"Почему автоматический failover не сработал, хотя первичная реплика "висит" с базой данных в состоянии SUSPECT?"* Правильный ответ — проверить настройку `DB_FAILOVER`. Если она выключена, AG не считает это состояние критическим для всей реплики.

---

### **2. Принудительное переключение (Forced Failover) после потери первичной**

**Короткий ответ: Да, принудительное переключение инициируется на ВТОРИЧНОЙ реплике, когда первичная утрачена или недоступна.**

Это операция "последнего средства" (last resort), выполняемая с помощью команды `FORCE_FAILOVER_ALLOW_DATA_LOSS`. Она **гарантированно приводит к потере данных**.

**Как это работает:**
1.  Вы подключаетесь к **одной из оставшихся вторичных реплик** (она может быть как синхронной, так и асинхронной).
2.  Выполняете команду, которая принудительно переводит эту реплику в роль **первичной**.
3.  Система **не дожидается** полной синхронизации и применяет все журналы транзакций, которые успела получить, даже если это означает "отрезать" последнюю часть незавершенной транзакции. Все данные, которые были зафиксированы на старой первичной реплике, но не дошли до этой вторичной, **будут потеряны навсегда**.
4.  Остальные реплики (включая старую первичную, если она "оживет") должны быть вручную перенастроены и присоединены к новой конфигурации.

**Команда в T-SQL (выполняется на целевой ВТОРИЧНОЙ реплике):**
```sql
-- ВАЖНО: Выполняется на реплике, которую хотите сделать новой первичной
ALTER AVAILABILITY GROUP [Your_AG_Name] FORCE_FAILOVER_ALLOW_DATA_LOSS;
```

**Порядок действий при аварии:**
1.  Убедитесь, что первичная реплика действительно потеряна и не вернется в ближайшие минуты.
2.  Определите **наиболее актуальную вторичную реплику** (с наименьшим `redo_queue_size`).
3.  Подключитесь к этой вторичной реплике и выполните команду принудительного переключения.
4.  После восстановления старой первичной реплики устраните в ней повреждения и переконфигурируйте её как новую вторичную реплику.

### **Сравнение типов Failover**

| Тип Failover | Условия | Инициируется на | Потеря данных (RPO) | Основное применение |
| :--- | :--- | :--- | :--- | :--- |
| **Автоматический** | Обе реплики синхронны и `SYNCHRONIZED`, `AUTOMATIC` | Системой кластера | **Нет** (RPO=0) | Плановая высокая доступность (HA) |
| **Плановый ручной** | Обе реплики синхронны и `SYNCHRONIZED` | **Первичной** реплике (команда) | **Нет** (RPO=0) | Обслуживание (patching) |
| **Принудительный** | Потеря первичной реплики | **Вторичной** реплике (команда) | **Да** (RPO > 0) | Аварийное восстановление (DR) |

**Вывод для собеседования:**
*   **Database-Level Health Detection** — это "датчик", который заставляет AG реагировать на смерть отдельной БД.
*   **Forced Failover** — это "аварийный выключатель", который дергают на уцелевшей вторичной реплике, чтобы хоть как-то запустить систему после катастрофы, осознанно жертвуя данными.
