## **RPO и RTO в контексте SQL Server AlwaysOn**

### **1. Определения (Теория)**

*   **RPO (Recovery Point Objective) — Целевая точка восстановления**
    *   **Вопрос на который отвечает:** *"Сколько данных мы можем позволить себе ПОТЕРЯТЬ?"*
    *   **Что это:** Максимально допустимый период времени, на который могут быть утрачены обновления данных из-за инцидента. Измеряется во **времени** (минуты, часы).
    *   **Простыми словами:** Насколько "старыми" могут быть последние доступные данные после аварии. **RPO = 5 мин** означает, что при сбое в 14:00, последняя доступная копия данных будет на момент 13:55.
    *   **За что отвечает в AG:** За **режим репликации и отставание (lag) вторичной реплики**.

*   **RTO (Recovery Time Objective) — Целевое время восстановления**
    *   **Вопрос на который отвечает:** *"Как долго система может быть НЕДОСТУПНА?"*
    *   **Что это:** Максимально допустимая длительность простоя приложения/сервиса после инцидента. Также измеряется во **времени**.
    *   **Простыми словами:** Сколько времени уходит на то, чтобы "поднять" систему и дать пользователям доступ. **RTO = 15 мин** означает, что с момента сбоя до момента, когда приложение снова работает, должно пройти не более 15 минут.
    *   **За что отвечает в AG:** За **процесс отработки отказа (failover) и готовность инфраструктуры**.

**Аналогия с поездом:**
*   **RPO** — На какой предыдущей станции у нас есть последняя полная копия багажа (данных) после крушения.
*   **RTO** — Через какое время мы сможем отправить следующий поезд (восстановить сервис).

---

### **2. Как AlwaysOn Availability Groups влияет на RPO и RTO?**

#### **Влияние на RPO (Защита данных)**

| Режим репликации в AG | Влияние на RPO | Механизм |
| :--- | :--- | :--- |
| **Синхронная фиксация (Synchronous Commit)** | **RPO ≈ 0 (Zero Data Loss)** | Транзакция фиксируется на первичной только после подтверждения записи на диск синхронной вторичной реплики. При сбое первичной данные есть на другой реплике. |
| **Асинхронная фиксация (Asynchronous Commit)** | **RPO > 0 (Возможна потеря данных)** | RPO равен **отставанию вторичной реплики (lag)**. Это время между фиксацией транзакции на первичной и ее применением на вторичной. Зависит от сети и нагрузки. |

**Как измерить текущий RPO для асинхронной реплики?**
Запрос к DMV покажет, насколько вторичная реплика отстает от первичной **в данных** (не во времени напрямую, но это косвенный показатель):
```sql
-- На первичной реплике
SELECT ar.replica_server_name,
       db_name(drs.database_id) as DB_Name,
       drs.last_commit_time, -- Время последней фиксированной транзакции на ПЕРВИЧНОЙ
       drs.last_commit_lsn
FROM sys.dm_hadr_database_replica_states drs
JOIN sys.availability_replicas ar ON drs.replica_id = ar.replica_id
ORDER BY drs.last_commit_time DESC;
```
Задержка во времени вычисляется сложнее и требует мониторинга метрик производительности.

#### **Влияние на RTO (Скорость восстановления)**

| Компонент/Настройка AG | Влияние на RTO | Пояснение |
| :--- | :--- | :--- |
| **Автоматический Failover (Automatic Failover)** | **Сокращает RTO до ~минут (1-3 мин)** | Кластер сам детектирует сбой и переключает роль без вмешательства человека. Основная часть времени уходит на фазу `RESOLVING` и `RECOVERY` (откат незавершенных транзакций — UNDO). |
| **Ручной Failover (Manual Failover)** | **Увеличивает RTO (десятки минут - часы)** | Зависит от скорости реакции DBA, наличия процедур, времени на проверки. |
| **Состояние реплики (Synchronized vs. Synchronizing)** | **Критично!** | Автоматический failover сработает **только** если вторичная реплика находится в состоянии `SYNCHRONIZED`. Если она `SYNCHRONIZING` (догоняет), автоматический переход заблокирован, RTO растет. |
| **Наличие прослушивателя (Listener)** | **Сокращает RTO для приложений** | Приложения используют одно имя для подключения. После failover им не нужно менять строки подключения (если не меняется порт). Влияет на *прикладной* RTO. |
| **Фаза восстановления (UNDO)** | **Основной фактор внутри RTO** | После перехода новая первичная реплика должна откатить незавершенные транзакции, которые были "в полете" на момент сбоя. Чем больше было активных больших транзакций, тем дольше UNDO и больше RTO. |

**Что может увеличить RTO в AG:**
1.  Долгий UNDO (как описано выше).
2.  Проблемы с кворумом кластера (кластер "зависает" в попытке определить, кто жив).
3.  Отсутствие автоматического failover (надо ждать DBA).
4.  Проблемы с DNS-кешированием имени прослушивателя на стороне клиентов (увеличивает *фактический* простой для пользователей, даже если БД уже работает).

---

### **3. Примеры настройки AG под разные требования к RPO/RTO**

| Бизнес-требование | Примерные значения | Рекомендуемая конфигурация AG | Пояснение |
| :--- | :--- | :--- | :--- |
| **Высокая доступность в одном ЦОДе** | RTO < 3 мин, RPO = 0 | **2-3 реплики в синхронном режиме.** Одна вторичная — с автоматическим failover. | Гарантия отсутствия потерь и быстрого автоматического переключения. |
| **Аварийное восстановление в удаленный ЦОД** | RTO < 1 час, RPO < 5 мин | **Первичная + синхронная реплика локально (для HA). + Асинхронная реплика в удаленный ЦОД (для DR).** | Локальный сбой — быстрое переключение без потерь. Катастрофа в основном ЦОДе — переключение на удаленный с потерей данных за последние несколько минут. |
| **Только отчетность и read-scale** | RTO не критично, RPO не критично | **Первичная + одна или несколько асинхронных реплик в режиме Readable Secondary.** | Цель — разгрузка первичной реплики. Отставание данных допустимо. |
| **Максимальная защита (критичная БД)** | RTO < 1 мин, RPO = 0 | **3 синхронные реплики (например, в разных стойках).** Конфигурация кворума "большинство узлов". Высокая готовность инфраструктуры (сеть, оборудование). | Дорогая конфигурация, требующая тщательного тестирования failover. |

---

### **4. Вопросы на собеседовании про RPO/RTO и ответы на них**

**Вопрос 1: "У вас есть требование RPO=0 и RTO<5 минут. Как вы построите решение на SQL Server?"**
**Ответ:**
«Для достижения RPO=0 необходимо использовать синхронную репликацию. Для RTO<5 минут нужен автоматический failover. Я бы развернул AlwaysOn Availability Group минимум с тремя репликами в одном ЦОДе или между ЦОДами с очень хорошей сетевой связностью:
1.  Первичная реплика.
2.  Синхронная вторичная реплика с автоматическим failover (это обеспечит RTO<5 мин).
3.  Еще одна синхронная или асинхронная реплика для дополнительной надежности и балансировки нагрузки на чтение.
Важно протестировать реальный RTO при отработке отказа, так как на него влияет фаза UNDO. Также необходимо настроить прослушиватель и убедиться, что приложения используют его с параметром `MultiSubnetFailover=True` для минимизации задержек подключения.»

**Вопрос 2: "При сбое первичной реплики в асинхронном режиме RPO составило 2 часа, хотя сеть хорошая. В чем причина?"**
**Ответ:**
«Если RPO (потеря данных) достигла 2 часов, это означает, что вторичная реплика отставала от первичной на 2 часа журналов транзакций. Причины могут быть следующие:
1.  **"Узкое место" на вторичной реплике (очередь REDO):** Наиболее вероятная причина. На вторичной реплике не хватало ресурсов (CPU, IO) для **применения** полученных журналов. Нужно смотреть `redo_queue_size` в DMV. Виновником часто являются длительные операции (индекс rebuild, массовые updates) на первичной.
2.  **Проблемы с сетью в прошлом:** Возможно, ранее были сетевые проблемы на 2 часа, которые устранились, но очередь отправки (send queue) так и не была выбрана.
3.  **Приостановка репликации:** Ручная приостановка репликации (`SUSPEND`) на длительное время.
Первым делом я бы проанализировал графики `redo_queue_size` и `log_send_queue_size` за последние сутки, а также нагрузку на CPU и диски вторичной реплики.»

**Вопрос 3: "Как мониторить текущие показатели RPO и RTO для вашей группы доступности?"**
**Ответ:**
«**Для мониторинга RPO (риска потери данных):**
Я использую DMV `sys.dm_hadr_database_replica_states`, отслеживая ключевые метрики:
*   `last_commit_time` (разница между репликами),
*   `log_send_queue_size` (неотправленные КБ),
*   `redo_queue_size` (непримененные КБ).
Эти метрики собираю в систему мониторинга (Zabbix, Prometheus) и строю дашборды.

**Для оценки RTO (времени простоя):**
Прямую метрику "текущее RTO" получить сложно, но я оцениваю **готовность к failover**:
1.  Состояние реплик (`synchronization_state_desc`) — должна быть `SYNCHRONIZED`.
2.  Наличие автоматического failover.
3.  Регулярно **тестирую процедуру отработки отказа** в тестовой среде и замеряю реальное время от сбоя до восстановления работы приложения. Это и есть контрольное значение RTO.
Также мониторю здоровье кластера WSFC и работу прослушивателя.»

---

**Резюме:**
*   **RPO** — про **данные**. Решается **режимом репликации** (синхронный/асинхронный).
*   **RTO** — про **время**. Решается **автоматическим failover** и **оптимизацией фазы восстановления**.

