## **Уровни изоляции в SQL Server: детальный разбор**

### **1. READ UNCOMMITTED (грязное чтение)**

```sql
-- Сессия 1
BEGIN TRANSACTION
UPDATE Accounts SET Balance = 1000 WHERE AccountID = 1
-- НЕ COMMIT еще!

-- Сессия 2
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SELECT Balance FROM Accounts WHERE AccountID = 1
-- Увидит 1000 (незакоммиченные данные!)

-- Сессия 1
ROLLBACK  -- Откатываем
-- Баланс снова 500, но Сессия 2 уже увидела 1000
```

**Что допускает:** Dirty Reads, Non-repeatable Reads, Phantom Reads
**Что блокирует:** Ничего (самый слабый уровень)
**Блокировки на чтение:** Нет блокировок, читает любые данные
**Блокировки на запись:** UPDATE/DELETE блокируют как обычно
**Когда использовать:** Только для отчетов, где точность не критична

### **2. READ COMMITTED (по умолчанию)**

```sql
-- Сессия 1
BEGIN TRANSACTION
UPDATE Accounts SET Balance = 1000 WHERE AccountID = 1

-- Сессия 2
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
SELECT Balance FROM Accounts WHERE AccountID = 1
-- Будет ЖДАТЬ, пока Сессия 1 не завершит транзакцию!
-- После COMMIT увидит 1000

-- Но проблема Non-repeatable Read остается:
-- Сессия 2: SELECT → видит 500
-- Сессия 1: UPDATE → COMMIT (становится 1000)
-- Сессия 2: SELECT → видит 1000 (значение изменилось!)
```

**Что допускает:** Non-repeatable Reads, Phantom Reads  
**Что блокирует:** Dirty Reads
**Блокировки на чтение:** Shared locks только на момент чтения строки
**Блокировки на запись:** Exclusive locks до конца транзакции
**Вариант:** READ_COMMITTED_SNAPSHOT (через snapshot, без блокировок)

### **3. REPEATABLE READ**

```sql
-- Сессия 1
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
BEGIN TRANSACTION
SELECT Balance FROM Accounts WHERE AccountID = 1
-- Удерживает Shared lock на строке AccountID = 1

-- Сессия 2
UPDATE Accounts SET Balance = 2000 WHERE AccountID = 1
-- БУДЕТ ЖДАТЬ! Не может получить Exclusive lock

-- Сессия 1
SELECT Balance FROM Accounts WHERE AccountID = 1
-- Всегда увидит одно и то же значение
COMMIT  -- Освобождает lock, теперь Сессия 2 может обновить

-- Но Phantom Reads возможны:
-- Сессия 1: SELECT * FROM Accounts WHERE Balance > 1000 → 0 строк
-- Сессия 2: INSERT INTO Accounts VALUES (999, 2000) → COMMIT
-- Сессия 1: SELECT * FROM Accounts WHERE Balance > 1000 → 1 строка!
```

**Что допускает:** Phantom Reads
**Что блокирует:** Dirty Reads, Non-repeatable Reads
**Блокировки на чтение:** Shared locks до конца транзакции
**Блокировки на запись:** Exclusive locks до конца транзакции
**Когда использовать:** Когда нужно гарантировать, что прочитанные данные не изменятся

### **4. SERIALIZABLE**

```sql
-- Сессия 1
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
BEGIN TRANSACTION
SELECT * FROM Accounts WHERE Balance > 1000
-- Блокирует ВЕСЬ диапазон Balance > 1000 (Key-Range locks)

-- Сессия 2
INSERT INTO Accounts VALUES (999, 2000)  -- Balance = 2000 > 1000
-- БУДЕТ ЖДАТЬ! Не может вставить в заблокированный диапазон

-- Сессия 1
SELECT * FROM Accounts WHERE Balance > 1000  -- Та же выборка
-- Гарантированно увидит те же строки
COMMIT  -- Освобождает диапазон
```

**Что допускает:** Ничего (самый строгий уровень)
**Что блокирует:** Dirty Reads, Non-repeatable Reads, Phantom Reads
**Блокировки на чтение:** Key-Range locks на весь диапазон
**Блокировки на запись:** Exclusive locks + Key-Range locks
**Когда использовать:** Критичные финансовые операции, где важна полная изоляция

### **5. SNAPSHOT**

```sql
-- Включаем на уровне БД
ALTER DATABASE MyDB SET ALLOW_SNAPSHOT_ISOLATION ON

-- Сессия 1
SET TRANSACTION ISOLATION LEVEL SNAPSHOT
BEGIN TRANSACTION
SELECT Balance FROM Accounts WHERE AccountID = 1
-- Читает из snapshot (версия данных на момент начала транзакции)

-- Сессия 2
UPDATE Accounts SET Balance = 2000 WHERE AccountID = 1
COMMIT  -- Меняет текущее значение

-- Сессия 1
SELECT Balance FROM Accounts WHERE AccountID = 1
-- Все еще видит старое значение (из snapshot)!
COMMIT  -- После COMMIT будет видеть новое значение

-- При UPDATE в SNAPSHOT:
-- Сессия 1 (SNAPSHOT): UPDATE Accounts SET Balance = 3000 WHERE AccountID = 1
-- Если Сессия 2 уже изменила эту строку → ОШИБКА 3960 (конфликт обновления)
```

**Что допускает:** --- (изоляция через версионирование)
**Что блокирует:** Все проблемы через snapshot
**Блокировки на чтение:** Нет блокировок (читает из tempdb)
**Блокировки на запись:** Exclusive locks на изменяемые строки
**Когда использовать:** Высококонкурентные системы, где много читателей

## **Сравнительная таблица**

| Уровень изоляции | Dirty Read | Non-repeatable Read | Phantom Read | Блокировки чтения | Конфликты UPDATE |
|-----------------|------------|---------------------|--------------|-------------------|------------------|
| **READ UNCOMMITTED** | ✅ Да | ✅ Да | ✅ Да | Нет | Да |
| **READ COMMITTED** | ❌ Нет | ✅ Да | ✅ Да | Мгновенные | Да |
| **REPEATABLE READ** | ❌ Нет | ❌ Нет | ✅ Да | До COMMIT | Да |
| **SERIALIZABLE** | ❌ Нет | ❌ Нет | ❌ Нет | Диапазоны до COMMIT | Да |
| **SNAPSHOT** | ❌ Нет | ❌ Нет | ❌ Нет | Нет (snapshot) | Конфликт версий |

## **Практические примеры влияния на блокировки**

### **Пример 1: Длительная транзакция с разными уровнями**

```sql
-- Сценарий: транзакция читает, думает 5 секунд, читает снова

-- READ COMMITTED (по умолчанию)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
BEGIN TRANSACTION
SELECT * FROM Products WHERE CategoryID = 1  -- Кратковременные S-locks
WAITFOR DELAY '00:00:05'  -- Думаем...
SELECT * FROM Products WHERE CategoryID = 1  -- Новые S-locks, могут быть другие данные
COMMIT
-- Другие сессии могут обновлять строки между SELECT'ами

-- REPEATABLE READ
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ  
BEGIN TRANSACTION
SELECT * FROM Products WHERE CategoryID = 1  -- S-locks УДЕРЖИВАЮТСЯ
WAITFOR DELAY '00:00:05'
SELECT * FROM Products WHERE CategoryID = 1  -- Те же данные гарантированно
COMMIT  -- Только теперь locks отпускаются
-- Другие сессии НЕ МОГУТ обновлять эти строки до COMMIT
```

### **Пример 2: Вставка в конкурентной среде**

```sql
-- SERIALIZABLE vs READ COMMITTED

-- SERIALIZABLE предотвращает Phantom Reads
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
BEGIN TRANSACTION
SELECT COUNT(*) FROM Orders WHERE OrderDate = '2024-01-15'
-- Блокирует ВЕСЬ диапазон OrderDate = '2024-01-15'

-- Другая сессия пытается вставить:
INSERT INTO Orders (OrderDate) VALUES ('2024-01-15')  -- ЖДЕТ!

COMMIT  -- Теперь вставка может выполниться
```

### **Пример 3: SNAPSHOT изоляция для отчетов**

```sql
-- Включаем SNAPSHOT для базы
ALTER DATABASE SalesDB SET ALLOW_SNAPSHOT_ISOLATION ON

-- Длительный отчет (не блокирует операционные данные)
SET TRANSACTION ISOLATION LEVEL SNAPSHOT
BEGIN TRANSACTION
-- Сложные агрегации на 5 минут
SELECT Category, SUM(Sales), AVG(Price) 
FROM Sales 
GROUP BY Category
-- Читает из snapshot, не блокирует обновления!
COMMIT

-- В это время операционные системы работают:
UPDATE Sales SET Price = Price * 1.1 WHERE Category = 'Electronics'
-- Не конфликтует с отчетом!
```

## **Каверзные вопросы на собеседовании**

1. **"В чем разница между READ_COMMITTED и READ_COMMITTED_SNAPSHOT?"**
   - **Ответ**: 
   ```sql
   -- READ_COMMITTED (по умолчанию): использует блокировки
   -- READ_COMMITTED_SNAPSHOT: читает из snapshot строки
   
   ALTER DATABASE MyDB SET READ_COMMITTED_SNAPSHOT ON
   -- Теперь READ COMMITTED работает через snapshot, без блокировок
   ```

2. **"Почему SNAPSHOT может вызывать ошибку 3960?"**
   - **Ответ**: Конфликт обновления при optimistic concurrency:
   ```sql
   -- Сессия 1 (SNAPSHOT): читает строку (версия 1)
   -- Сессия 2: обновляет строку (версия 2)
   -- Сессия 1: пытается обновить → ошибка, так как версия изменилась
   ```

3. **"Как выбрать уровень изоляции для системы бронирования?"**
   - **Ответ**: SERIALIZABLE или REPEATABLE READ с ручной проверкой:
   ```sql
   -- Бронирование мест (важен диапазон)
   SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
   BEGIN TRANSACTION
   SELECT COUNT(*) FROM Seats WHERE FlightID = 123 AND Booked = 0
   -- Если есть места, бронируем
   UPDATE Seats SET Booked = 1 WHERE SeatID = @SeatID
   COMMIT
   ```

4. **"Что такое Key-Range locks и когда они возникают?"**
   - **Ответ**: Блокировки диапазонов ключей в SERIALIZABLE:
   ```sql
   -- Блокирует не только существующие строки, но и "потенциальные"
   SELECT * FROM Table WHERE ID BETWEEN 100 AND 200
   -- Запрещает вставку ID = 150, даже если такой строки нет!
   ```

## **Рекомендации по выбору уровня изоляции**

```sql
-- Правило выбора:
-- 1. Операционные системы (OLTP) → READ COMMITTED (или SNAPSHOT)
-- 2. Финансовые операции → REPEATABLE READ или SERIALIZABLE  
-- 3. Отчеты и аналитика → READ UNCOMMITTED или SNAPSHOT
-- 4. Высокая конкурентность чтения → READ_COMMITTED_SNAPSHOT

-- Проверка текущих настроек
SELECT 
    name,
    is_read_committed_snapshot_on,
    snapshot_isolation_state_desc
FROM sys.databases 
WHERE name = DB_NAME()

-- Мониторинг блокировок по уровням изоляции
SELECT 
    CASE transaction_isolation_level 
        WHEN 0 THEN 'Unspecified'
        WHEN 1 THEN 'ReadUncommitted' 
        WHEN 2 THEN 'ReadCommitted'
        WHEN 3 THEN 'Repeatable'
        WHEN 4 THEN 'Serializable'
        WHEN 5 THEN 'Snapshot'
    END AS isolation_level,
    COUNT(*) as session_count
FROM sys.dm_exec_sessions
WHERE is_user_process = 1
GROUP BY transaction_isolation_level
```

## **Опасные комбинации**

```sql
-- ОПАСНО: Смешивание уровней в одной транзакции
BEGIN TRANSACTION
SELECT * FROM Table1 WITH (NOLOCK)  -- READ UNCOMMITTED
SELECT * FROM Table2  -- Уровень сессии (например, READ COMMITTED)
-- Непредсказуемое поведение!

-- ОПАСНО: SERIALIZABLE с долгими транзакциями
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
BEGIN TRANSACTION
SELECT * FROM LargeTable  -- Блокирует диапазоны
WAITFOR DELAY '00:05:00'  -- 5 минут!
-- Весь диапазон заблокирован на 5 минут → deadlocks!
COMMIT
```

**Ключевой вывод:** Уровень изоляции — это компромисс между **консистентностью данных** и **конкурентностью**. Чем строже изоляция, тем больше блокировок и тем ниже производительность при конкурентном доступе.
