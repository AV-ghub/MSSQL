## **Вопрос 1**
**В T-SQL нет встроенного типа данных "массив"**. Это классический каверзный вопрос, который проверяет понимание того, как обходить ограничения SQL. Вот все практические способы передачи набора данных в хранимую процедуру:

## **1. XML (универсальный, но многословный)** ✅

```sql
-- Создание процедуры
CREATE PROCEDURE ProcessEmployeesXML
    @EmployeeIDs XML
AS
BEGIN
    SELECT 
        T.c.value('.', 'INT') AS EmployeeID
    INTO #TempIDs
    FROM @EmployeeIDs.nodes('/IDs/ID') T(c)
    
    SELECT * FROM Employees 
    WHERE EmployeeID IN (SELECT EmployeeID FROM #TempIDs)
END
GO

-- Вызов
DECLARE @ids XML = '<IDs><ID>1</ID><ID>3</ID><ID>5</ID></IDs>'
EXEC ProcessEmployeesXML @EmployeeIDs = @ids
```

## **2. JSON (современный, начиная с SQL Server 2016)** ✅

```sql
CREATE PROCEDURE ProcessEmployeesJSON
    @EmployeeIDs NVARCHAR(MAX)
AS
BEGIN
    SELECT value AS EmployeeID
    INTO #TempIDs
    FROM OPENJSON(@EmployeeIDs)
    
    SELECT * FROM Employees 
    WHERE EmployeeID IN (SELECT EmployeeID FROM #TempIDs)
END
GO

-- Вызов
EXEC ProcessEmployeesJSON @EmployeeIDs = '[1, 3, 5]'
-- Или с именами
EXEC ProcessEmployeesJSON @EmployeeIDs = '{"ids": [1, 3, 5]}'
```

## **3. CSV-строка с разделителями** ✅

```sql
CREATE PROCEDURE ProcessEmployeesCSV
    @EmployeeIDs VARCHAR(MAX)
AS
BEGIN
    -- Самый простой способ (SQL Server 2016+)
    SELECT value AS EmployeeID
    INTO #TempIDs
    FROM STRING_SPLIT(@EmployeeIDs, ',')
    
    -- Для версий до 2016 нужна своя функция split
    SELECT * FROM Employees 
    WHERE EmployeeID IN (SELECT EmployeeID FROM #TempIDs)
END
GO

-- Вызов
EXEC ProcessEmployeesCSV @EmployeeIDs = '1,3,5,7,9'
```

## **4. Табличный параметр (Table-Valued Parameter - TVP)** ✅ **Рекомендуемый способ**

```sql
-- 1. Создаем пользовательский тип таблицы
CREATE TYPE dbo.IntList AS TABLE 
(
    ID INT PRIMARY KEY
)
GO

-- 2. Создаем процедуру с параметром этого типа
CREATE PROCEDURE ProcessEmployeesTVP
    @EmployeeIDs dbo.IntList READONLY
AS
BEGIN
    SELECT e.* 
    FROM Employees e
    INNER JOIN @EmployeeIDs ids ON e.EmployeeID = ids.ID
END
GO

-- 3. Вызов из T-SQL
DECLARE @ids dbo.IntList
INSERT INTO @ids VALUES (1), (3), (5), (7), (9)

EXEC ProcessEmployeesTVP @EmployeeIDs = @ids
```

## **5. Временная таблица** ✅

```sql
CREATE PROCEDURE ProcessEmployeesTempTable
    -- Без параметров-массивов!
AS
BEGIN
    -- Процедура ожидает, что временная таблица уже создана
    SELECT e.* 
    FROM Employees e
    INNER JOIN #TempEmployeeIDs ids ON e.EmployeeID = ids.ID
END
GO

-- Вызов
CREATE TABLE #TempEmployeeIDs (ID INT)
INSERT INTO #TempEmployeeIDs VALUES (1), (3), (5)

EXEC ProcessEmployeesTempTable

DROP TABLE #TempEmployeeIDs
```

## **Сравнение методов**

| Метод | Производительность | Читаемость | Поддержка версий | Использование в JOIN |
|-------|-------------------|------------|------------------|----------------------|
| **TVP** | ⭐⭐⭐⭐⭐ (лучшая) | ⭐⭐⭐⭐⭐ | SQL 2008+ | Да |
| **JSON** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | SQL 2016+ | Да (после распарсивания) |
| **XML** | ⭐⭐⭐ | ⭐⭐ | SQL 2005+ | Да (после распарсивания) |
| **CSV** | ⭐⭐ | ⭐⭐⭐ | Все (со STRING_SPLIT с 2016) | Да (после распарсивания) |
| **Temp Table** | ⭐⭐⭐⭐ | ⭐⭐ | Все | Да |

## **Вызов TVP из C# (частый доп. вопрос)**

```csharp
// Создаем DataTable
DataTable employeeIds = new DataTable();
employeeIds.Columns.Add("ID", typeof(int));
employeeIds.Rows.Add(1);
employeeIds.Rows.Add(3);
employeeIds.Rows.Add(5);

// Передаем как параметр
using (SqlCommand cmd = new SqlCommand("ProcessEmployeesTVP", connection))
{
    cmd.CommandType = CommandType.StoredProcedure;
    SqlParameter param = cmd.Parameters.AddWithValue("@EmployeeIDs", employeeIds);
    param.SqlDbType = SqlDbType.Structured;
    param.TypeName = "dbo.IntList";
    
    using (SqlDataReader reader = cmd.ExecuteReader())
    {
        // Обработка результатов
    }
}
```

## **Каверзные уточняющие вопросы на собеседовании**

1. **"А если нужно передать 100 000 ID? Какой метод выбрать?"**
   - **Ответ**: TVP, так как он наиболее эффективен для больших объемов данных.

2. **"Как отследить производительность каждого метода?"**
   ```sql
   -- Включите статистику ввода-вывода и времени
   SET STATISTICS IO ON
   SET STATISTICS TIME ON
   -- Выполните процедуру разными способами
   ```

3. **"Можно ли модифицировать TVP внутри процедуры?"**
   - **Ответ**: Нет, TVP параметры всегда `READONLY`. Если нужно изменять, скопируйте во временную таблицу.

4. **"Как быть, если SQL Server 2005 и нет TVP?"**
   - **Ответ**: Использовать XML или CSV-строку с пользовательской функцией split.

## **Правильный ответ для собеседования**

> "В T-SQL нет нативного типа 'массив', но есть несколько способов эмуляции:
> 1. **Table-Valued Parameters (TVP)** - рекомендуемый способ с SQL Server 2008+
> 2. **JSON** - для SQL Server 2016+
> 3. **XML** - универсально, но многословно
> 4. **CSV-строка** с функцией `STRING_SPLIT` (SQL 2016+) или пользовательской функцией
> 5. **Временная таблица** - когда вызывающий код может её создать
> 
> Выбор зависит от версии SQL Server, объема данных и требований к производительности."

