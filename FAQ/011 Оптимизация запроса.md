## **Системный подход к оптимизации запросов**

### **Первое: План выполнения (Execution Plan)**

> **"Первым делом смотрю план выполнения. Ищу ключевые операторы: Table Scan вместо Seek, высокий процент стоимости у определенных операций, Key Lookups, Sorts в памяти, недостающие индексы."**

```sql
-- Получаем план
SET STATISTICS PROFILE ON
-- или
SET SHOWPLAN_XML ON

-- Выполняем проблемный запрос
SELECT * FROM Orders WHERE Status = 'Pending' AND OrderDate > '2024-01-01'

-- Анализируем визуально или через XML
SELECT 
    query_plan.value('declare default element namespace 
        "http://schemas.microsoft.com/sqlserver/2004/07/showplan";
        (//RelOp/@EstimatedTotalSubtreeCost)[1]', 'float') AS TotalCost,
    query_plan
FROM sys.dm_exec_cached_plans
CROSS APPLY sys.dm_exec_query_plan(plan_handle)
WHERE objtype = 'Adhoc'
```

### **Второе: Статистика по вводу-выводу и времени**

```sql
SET STATISTICS IO, TIME ON

-- Выполняем запрос
/*
Результат:
Table 'Orders'. Scan count 1, logical reads 15896, physical reads 0...
SQL Server Execution Times: CPU time = 203 ms, elapsed time = 215 ms
*/

-- Ключевые метрики:
-- 1. Logical reads (чтения из памяти) - должны быть минимизированы
-- 2. Physical reads (чтения с диска) - если > 0, возможно нехватка памяти
-- 3. CPU time vs Elapsed time (если сильно различаются - ожидания)
-- 4. Scan count > 1 (возможно Nested Loops или пересканирование)
```

### **Третье: Анализ основных проблемных паттернов**

#### **1. Table/Index Scan вместо Seek**
```sql
-- Проблема: полное сканирование
SELECT * FROM Customers WHERE LastName LIKE '%son'

-- Решение: SARGable условия, индексы
CREATE INDEX IX_Customers_LastName ON Customers(LastName)
SELECT * FROM Customers WHERE LastName LIKE 'Ander%'  -- Теперь Seek
```

#### **2. Key Lookup (пропущенные индексы)**
```sql
-- В плане: Index Seek -> Key Lookup (дорого!)
SELECT CustomerID, FirstName, LastName, Email 
FROM Customers 
WHERE LastName = 'Smith'

-- Решение: покрывающий индекс
CREATE INDEX IX_Customers_LastName_Covering 
ON Customers(LastName) INCLUDE (FirstName, Email)
```

#### **3. Implicit Conversion (неявное преобразование)**
```sql
-- Проблема: Index Scan из-за преобразования типа
SELECT * FROM Orders WHERE OrderID = '12345'  -- OrderID INT, '12345' VARCHAR

-- Решение: соответствие типов
SELECT * FROM Orders WHERE OrderID = 12345
```

#### **4. Предикаты с функциями**
```sql
-- Проблема: не-SARGable
SELECT * FROM Orders WHERE YEAR(OrderDate) = 2024

-- Решение: SARGable диапазон
SELECT * FROM Orders 
WHERE OrderDate >= '2024-01-01' AND OrderDate < '2025-01-01'
```

### **Четвертое: Анализ реальных метрик через DMV**

```sql
-- Найти самые тяжелые запросы
SELECT TOP 10
    qs.execution_count,
    qs.total_worker_time / 1000 AS total_cpu_ms,
    qs.total_elapsed_time / 1000 AS total_duration_ms,
    qs.total_logical_reads,
    qs.total_logical_writes,
    qs.total_physical_reads,
    SUBSTRING(st.text, 
              (qs.statement_start_offset/2) + 1,
              ((CASE qs.statement_end_offset 
                WHEN -1 THEN DATALENGTH(st.text)
                ELSE qs.statement_end_offset 
                END - qs.statement_start_offset)/2) + 1) AS query_text,
    qp.query_plan
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) st
CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp
ORDER BY qs.total_worker_time DESC  -- По CPU
-- или ORDER BY qs.total_logical_reads DESC  -- По чтениям
```

### **Пятое: Checklist для быстрого анализа**

```sql
-- 1. Проверить наличие индексов
EXEC sp_helpindex 'Orders'

-- 2. Проверить статистику
DBCC SHOW_STATISTICS('Orders', 'IX_Orders_Date')

-- 3. Проверить fragmentation
SELECT 
    OBJECT_NAME(ips.object_id) AS TableName,
    i.name AS IndexName,
    ips.avg_fragmentation_in_percent
FROM sys.dm_db_index_physical_stats(
    DB_ID(), NULL, NULL, NULL, 'LIMITED') ips
JOIN sys.indexes i ON ips.object_id = i.object_id 
    AND ips.index_id = i.index_id
WHERE avg_fragmentation_in_percent > 30  -- Требует REBUILD

-- 4. Проверить memory grants
SELECT 
    session_id,
    requested_memory_kb,
    granted_memory_kb,
    used_memory_kb,
    max_used_memory_kb
FROM sys.dm_exec_query_memory_grants
```

## **Практический пример оптимизации**

### **Исходный проблемный запрос:**
```sql
-- Медленный запрос отчетов
SELECT 
    c.CustomerName,
    o.OrderDate,
    o.TotalAmount,
    p.ProductName,
    od.Quantity,
    od.UnitPrice
FROM Customers c
JOIN Orders o ON c.CustomerID = o.CustomerID
JOIN OrderDetails od ON o.OrderID = od.OrderID
JOIN Products p ON od.ProductID = p.ProductID
WHERE o.OrderDate BETWEEN @StartDate AND @EndDate
    AND c.Country = @Country
    AND p.CategoryID = @CategoryID
ORDER BY o.OrderDate DESC
```

### **Шаг 1: Анализ плана**
```sql
-- Видим в плане:
-- 1. Table Scan на Orders (нет индекса по OrderDate)
-- 2. Key Lookup на OrderDetails (нет покрывающего индекса)
-- 3. Hash Match вместо Nested Loops (большие таблицы)

-- Стоимость операторов:
-- Table Scan (Orders): 45%
-- Hash Match (Join): 30%
-- Sort: 15%
-- Остальное: 10%
```

### **Шаг 2: Добавление индексов**
```sql
-- 1. Индекс для фильтрации Orders
CREATE INDEX IX_Orders_Date_Country ON Orders(OrderDate, CustomerID)
INCLUDE (TotalAmount)  -- Покрывающий для TotalAmount

-- 2. Индекс для Customers
CREATE INDEX IX_Customers_Country ON Customers(Country, CustomerID)
INCLUDE (CustomerName)

-- 3. Индекс для OrderDetails
CREATE INDEX IX_OrderDetails_OrderID ON OrderDetails(OrderID, ProductID)
INCLUDE (Quantity, UnitPrice)

-- 4. Индекс для Products
CREATE INDEX IX_Products_Category ON Products(CategoryID, ProductID)
INCLUDE (ProductName)
```

### **Шаг 3: Переписание запроса (при необходимости)**
```sql
-- Использование CTE для разделения
WITH FilteredOrders AS (
    SELECT OrderID, CustomerID, OrderDate, TotalAmount
    FROM Orders
    WHERE OrderDate BETWEEN @StartDate AND @EndDate
),
FilteredCustomers AS (
    SELECT CustomerID, CustomerName
    FROM Customers
    WHERE Country = @Country
)
SELECT 
    fc.CustomerName,
    fo.OrderDate,
    fo.TotalAmount,
    p.ProductName,
    od.Quantity,
    od.UnitPrice
FROM FilteredOrders fo
JOIN FilteredCustomers fc ON fo.CustomerID = fc.CustomerID
JOIN OrderDetails od ON fo.OrderID = od.OrderID
JOIN Products p ON od.ProductID = p.ProductID
    AND p.CategoryID = @CategoryID  -- Перенесли условие в JOIN
ORDER BY fo.OrderDate DESC
```

### **Шаг 4: Оптимизация параметров**
```sql
-- Использование локальных переменных для предсказуемости плана
DECLARE @StartDateLocal DATE = @StartDate,
        @EndDateLocal DATE = @EndDate,
        @CountryLocal NVARCHAR(50) = @Country,
        @CategoryIDLocal INT = @CategoryID

-- OPTION для подсказок оптимизатору
OPTION (
    RECOMPILE,  -- Перекомпиляция для актуальных параметров
    MAXDOP 4,   -- Ограничение параллелизма
    OPTIMIZE FOR (@StartDateLocal = '2024-01-01')  -- Оптимизация под типичный сценарий
)
```

### **Шаг 5: Мониторинг результатов**
```sql
-- До оптимизации:
-- CPU: 1200ms, Reads: 150,000, Duration: 2500ms

-- После оптимизации:
-- CPU: 150ms, Reads: 8,000, Duration: 300ms
```

## **Каверзные вопросы на собеседовании**

1. **"Что делать, если план запроса меняется каждый раз?"**
   - **Ответ**: Проблема parameter sniffing. Решения:
   ```sql
   -- 1. RECOMPILE hint
   CREATE PROCEDURE GetOrders @StartDate DATE
   AS
   SELECT * FROM Orders WHERE OrderDate > @StartDate
   OPTION (RECOMPILE)
   
   -- 2. Локальные переменные
   DECLARE @LocalDate DATE = @StartDate
   SELECT * FROM Orders WHERE OrderDate > @LocalDate
   
   -- 3. OPTIMIZE FOR hint
   OPTION (OPTIMIZE FOR (@StartDate = '2023-01-01'))
   
   -- 4. План принудительного выполнения
   sp_create_plan_guide
   ```

2. **"Как оптимизировать запрос, если нельзя добавить индексы?"**
   - **Ответ**:
   ```sql
   -- 1. Изменить логику запроса
   -- 2. Использовать материализованные представления
   -- 3. Предварительная агрегация (ночные задания)
   -- 4. Изменение архитектуры (партицирование, columnstore)
   -- 5. Кэширование результатов на уровне приложения
   ```

3. **"Что такое 'плохой план запроса' и как его исправить?"**
   - **Ответ**: План с:
     - Table Scan вместо Seek
     - Неправильный тип Join (Hash вместо Nested Loops)
     - Избыточные Sorts
     - Высокая оценка строк vs реальность
   
   **Исправление:**
   ```sql
   -- 1. Обновить статистику
   UPDATE STATISTICS TableName WITH FULLSCAN
   
   -- 2. Перестроить индексы
   ALTER INDEX ALL ON TableName REBUILD
   
   -- 3. Использовать query hint
   OPTION (FORCE ORDER, LOOP JOIN)
   
   -- 4. Переписать запрос
   ```

4. **"Как оптимизировать запросы с LIKE '%pattern%'?"**
   - **Ответ**:
   ```sql
   -- 1. Полнотекстовый поиск
   CREATE FULLTEXT CATALOG ftCatalog
   CREATE FULLTEXT INDEX ON Products(ProductName)
   
   SELECT * FROM Products 
   WHERE CONTAINS(ProductName, '"кофе" AND "зерновой"')
   
   -- 2. Reverse index для суффиксов
   ALTER TABLE Products ADD ProductNameReversed AS REVERSE(ProductName)
   CREATE INDEX IX_Products_NameReversed ON Products(ProductNameReversed)
   
   SELECT * FROM Products 
   WHERE REVERSE(ProductName) LIKE REVERSE('%кофе')
   
   -- 3. N-gram разбиение для сложных поисков
   ```

## **Чеклист оптимизации**

```sql
-- Быстрая диагностика проблемы
/*
1. □ Проверить план выполнения (SET STATISTICS PROFILE ON)
2. □ Проверить IO/Time статистику (SET STATISTICS IO, TIME ON)
3. □ Искать Table/Index Scan вместо Seek
4. □ Проверить Key Lookups (RID Lookups)
5. □ Проверить Implicit Conversion
6. □ Проверить Sort/Spool в памяти
7. □ Проверить оценку строк vs реальность
8. □ Проверить фрагментацию индексов
9. □ Проверить актуальность статистики
10. □ Проверить memory grants
*/

-- Частые решения
/*
1. □ Добавить недостающий индекс
2. □ Создать покрывающий индекс
3. □ Переписать не-SARGable условия
4. □ Изменить тип JOIN
5. □ Разбить сложный запрос на части
6. □ Использовать временные таблицы
7. □ Добавить OPTION (RECOMPILE)
8. □ Обновить статистику
9. □ Перестроить индексы
10. □ Рассмотреть изменение архитектуры
*/
```

## **Профессиональный ответ на собеседовании**

> "Первым делом я смотрю на **план выполнения** и **статистику IO/TIME**. Ищу ключевые антипаттерны: Table Scan вместо Index Seek, высокую стоимость Key Lookups, не-SARGable условия, implicit conversion. Затем анализирую через sys.dm_exec_query_stats самые ресурсоемкие запросы. Оптимизирую в порядке приоритета: 1) Добавление недостающих индексов, 2) Переписывание запросов для SARGability, 3) Обновление статистики, 4) Изменение логики, если нужно."
